#+TITLE: clang-tags
#+STYLE: <link type="text/css" href="worg.css" title="Standard" rel="stylesheet">
#+STYLE: <link type="text/css" href="worg-zenburn.css" title="Zenburn" rel="alternate stylesheet">
#+STYLE: <link type="text/css" href="worg-classic.css" title="Classic" rel="alternate stylesheet">
#+STYLE: <style type="text/css">
#+STYLE:   #text-1 pre.src { float: left; margin-right: 3em }
#+STYLE:   #sec-1-1 { clear: both; }
#+STYLE: </style>
#+BIND: org-export-html-postamble "Generated by %c using CSS stylesheets from <a href='http://www.orgmode.org/worg'>Worg</a>."
#+OPTIONS: author:nil timestamp:nil level:4 toc:2

=clang-tags= is a C / C++ source code indexing tool. Unlike many other indexing
tools, =clang-tags= relies on the [[http://clang.llvm.org][clang]] compiler (via
the libclang interface) to analyse and index the source code base.


* Introduction

  Let us consider the following C++ code:

  #+NAME: example
  #+begin_src c++ -n -r
    #include "config.h"
    #include <iostream>
    
    #ifdef DEBUG
    inline void debug (const char* message) { (ref:debug1)
      std::cerr << message << std::endl;
    }
    #else
    inline void debug (const char* message) {(ref:debug2)}
    #endif
    
    template <typename T> struct MyClass {
      MyClass () { debug ("MyClass::MyClass"); (ref:defCtor) }
    
      void display () { (ref:defDisplayT)
        std::cout << "MyClass<T>::display()" << std::endl;
      }
    };
    
    template <> struct MyClass<int> {
      void display () { (ref:defDisplayInt)
        std::cout << "MyClass<int>::display()" << std::endl;
      }
    };
    
    int main () {
      int display = 3; (ref:display1)
    
      MyClass<double> a; (ref:ctor)
      a.display(); (ref:display2)
    
      MyClass<int> b;
      b.display(); (ref:display3)
    }
  #+end_src

  A few difficulties can be found in this file, making indexing difficult without the help of a
  full-fledged C++ compiler:

  1. Depending on the =DEBUG= preprocessor macro, the definition of the function =debug= might be found
     at line [[(debug1)]] or [[(debug2)]].

  2. The =display= identifier is used in several places to mean widely different things (for example
     at lines [[(display1)]] and [[(display2)]]). Context information is necessary to disambiguate uses of
     the same identifier.

  3. Even when =display= refers to the method of template class =MyClass<>=, a precise knowledge of the
     complex C++ template specialization rules is required to associate [[(display2)][a.display()]] with
     [[(defDisplayT)][MyClass<T>::display()]] and [[(display3)][b.display()]] with [[(defDisplayInt)][MyClass<int>::display()]].

  4. Some functions such as constructors or operators can be called without explicitly appearing in
     the code. For example, the [[(defCtor)][MyClass::MyClass()]] constructor is called at line [[(ctor)]].


  On the other hand, using a C++ compiler such as =clang= to parse this code and generate an AST
  requires information about the project configuration and its build environment:

  1. The =config.h= file could be automatically generated by =autoconf= or =CMake= and reside in a
     completely different directory than other source files. The compiler will typically need to be
     provided with =-I= command-line arguments to know where to find header files.

  2. The =DEBUG= macro could well be defined by the compilation command line (typically using a =-D=
     switch).

  A compiler-based indexing tool thus needs to be aware of the full compilation commands which are
  used to build the project, including for each source file:
  - the full list of command-line switches,
  - the directory from which the file is compiled.

  Such information, which we will refer to as a "compilation database" in the following, is usually
  found in the build system configuration, which can take a wide variety of forms: hand-crafted
  =Makefile=, =autotools= project, =CMake= project, /etc./

** Features

   =clang-tags= aims at providing the following features:
   1. generate a compilation database in a build-system-agnostic way,
   2. index the sources of the project,
   3. use this index to provide IDE-like features in Emacs.


** First steps for the impatient
    
   All details are explained later, but here are a few steps to get you started if
   you are too impatient to read. Otherwise, you may safely skip to the
   [[*Creating%20the%20compilation%20database][following section]].
    
   1. build the compilation database:
      #+begin_src sh
        ~> cd path/to/your/build/directory
        build> make clean
        build> clang-tags trace make
        [ 33%] Building CXX object CMakeFiles/getopt++.dir/getopt/getopt.cxx.o
        Linking CXX static library libgetopt++.a
        [ 33%] Built target getopt++
        [ 66%] Building CXX object CMakeFiles/clang-tags-def.dir/findDefinition.cxx.o
        Linking CXX executable clang-tags-def
        [ 66%] Built target clang-tags-def
        [100%] Building CXX object CMakeFiles/clang-tags-index.dir/index.cxx.o
        Linking CXX executable clang-tags-index
        [100%] Built target clang-tags-index
      #+end_src
    
   2. index the source files:
      #+begin_src sh
         build> clang-tags index --emacs-conf ../src/
         src/getopt/getopt.cxx...          1.27s.
         src/findDefinition.cxx...         0.34s.
         src/index.cxx...                  0.33s.
      #+end_src
    
   3. find the definition location of the identifier located in =index.cxx= at
      offset 902:
      #+begin_src ct/find-def
         build> clang-tags find-def ../src/index.cxx 902
         -- cursor.location().expansionLocation() -- CallExpr expansionLocation
            src/clang/sourceLocation.hxx:31-51:20-5: CXXMethod expansionLocation
            USR: c:@N@Clang@C@SourceLocation@F@expansionLocation#1
       
         -- cursor.location() -- CallExpr location
            src/clang/cursor.hxx:63-65:20-5: CXXMethod location
            USR: c:@N@Clang@C@Cursor@F@location#1
       
         -- cursor -- DeclRefExpr cursor
            src/index.cxx:21-21:23-40: VarDecl cursor
            USR: c:index.cxx@557@F@indexFile#$@SA@CXCursor#S0_#*v#@cursor
      #+end_src
    
   4. find all uses of the =Cursor::location()= method (identified by its USR, as
      given in the second result of =clang-tags find-def= above):
      #+begin_src grep
         build> clang-tags grep 'c:@N@Clang@C@Cursor@F@location#1'
         src/findDefinition.cxx:13:  const Clang::SourceLocation location(cursor.location());
         src/findDefinition.cxx:33:    const Clang::SourceLocation::Position begin = cursorDef.location().expansionLocation();
         src/findDefinition.cxx:52:  const Clang::SourceLocation location (cursor.location());
         src/findDefinition.cxx:131:    Clang::SourceLocation target = cursor.location();
         src/clang/cursor.hxx:63:    SourceLocation location () const {
         src/index.cxx:34:  const Clang::SourceLocation::Position begin = cursor.location().expansionLocation();
      #+end_src



* Creating the compilation database

  =clang-tags= uses a [[http://clang.llvm.org/docs/JSONCompilationDatabase.html][JSON compilation database]] to get the information needed to correctly build the
  project: compile directories and command-line switches. There are different ways to collect this
  information.

** From a =CMake= project

   =CMake= (since version 2.8.5) supports the generation of a compilation database with the option
   =CMAKE_EXPORT_COMPILE_COMMANDS=. For a =CMake=-managed project, creating the compilation database is
   thus as simple as:
   #+begin_src sh
     cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ../src
   #+end_src


** Tracing the standard build process

   #+begin_src sh
     clang-tags trace -- BUILD COMMAND
   #+end_src

   For non =CMake=-managed projects, there is no "free" way to build the compilation database. One
   way to get the necessary information consists in inspecting the build process as a black box
   using [[http://linux.die.net/man/1/strace][=strace(1)=]] (also see [[https://github.com/rizsotto/Bear][=Bear=]] for a tool using =LD_PRELOAD= to implement the same kind of
   strategy).

   Such a method is inherently independent of the build process: Makefile (possibly
   autotools-generated), shell or python script, ... However, the downside with this approach is
   that =make= and other build systems traditionally only rebuild what's needed, and the generated
   compilation database can thus be incomplete.

   Example usage:
   #+begin_src sh
     make clean                 # Ensure that the whole project will be rebuilt
     clang-tags trace -- make   # Generate the compilation database
   #+end_src


** Scanning the sources directory

   #+begin_src sh
     clang-tags scan SRC_DIR -- CLANG ARGS
   #+end_src

   For relatively simple projects, it can be sufficient to simply scan the top sources directory to
   find all =*.c= or =*.cxx= files, and additionally provide =clang-tags= with a set of command-line
   arguments necessary for =clang= to parse these files.

   Example usage:
   #+begin_src sh
     clang-tags scan ../src -- -I.
   #+end_src


* Indexing the source files

** Creating the index

   #+begin_src sh
   clang-tags index [--emacs-conf SRC_DIR]
   #+end_src

   This command uses the compilation database to index all source files. An
   optional argument =--emacs-conf= allows generating a suitable =.dir-local.el=
   emacs configuration file in the sources directory.

** Updating the index

   #+begin_src sh
   clang-tags update [--all]
   #+end_src

   This command updates the index. With the optional =--all= switch, the
   compilation database is also rebuilt using the same subcommand =trace= or
   =build= as previously.


* Using the Emacs UI

First, load the package using =M-x load-file RET path/to/clang-tags.el RET=

With the configuration file generated by the =clang-tags index= command, all
C/C++ source files in the indexed source directory should automatically activate
=clang-tags-mode= and have the =ct/default-directory= variable point to the
index directory.


** Find the definition of the symbol at point

While in a source buffer, you can use =clang-tags= to find the location of the definition
of the symbol under point by pressing =M-<dot>=.

The list of relevant definitions is presented in a buffer, where pressing =RET= will take you to the
location of the definition.

** Find all uses of a definition in the source base

After having looked for a definition of the symbol under point, and while in the definitions list
buffer, press =M-<comma>= to list all uses of the current definition in the source code base.

Results are presented in a =grep-mode= buffer.


* See also

- [[http://clang.llvm.org/doxygen/group__CINDEX.html][libclang API documentation]]
- [[http://llvm.org/devmtg/2010-11/Gregor-libclang.pdf][Doug Gregor's presentation on libclang]]
- [[https://github.com/drothlis/clang-ctags][clang-ctags]]: a similar project
  using libclang to generate =ctags= / =etags= index files.
