#+TITLE: Clang-tags
#+STYLE: <link rel="stylesheet" type="text/css" href="org.css"/>
#+OPTIONS: author:nil timestamp:nil creator:nil level:4 toc:2

=clang-tags= is a C / C++ source code indexing tool. Unlike many other indexing
tools, =clang-tags= relies on the [[http://clang.llvm.org][clang]] compiler (via
the libclang interface) to analyse and index the source code base.


* Introduction

  Let us consider the following C++ code:

  #+begin_src c++ -n -r
    #include "config.h"
    #include <iostream>

    #ifdef DEBUG
    inline void debug (const char* message) {  (ref:debug1)
      std::cerr << message << std::endl;
    }
    #else
    inline void debug (const char* message) {  (ref:debug2)
    }
    #endif

    template <typename T>
    struct MyClass {
      MyClass () { (ref:defCtor)
        debug ("MyClass::MyClass");
      }

      void display () { (ref:defDisplayT)
        std::cout << "MyClass<T>" << std::endl;
      }
    };

    template <>
    struct MyClass<int> {
      void display () { (ref:defDisplayInt)
        std::cout << "MyClass<int>" << std::endl;
      }
    };

    int main () {
      int display = 3; (ref:display1)

      MyClass<double> a; (ref:ctor)
      a.display(); (ref:display2)

      MyClass<int> b;
      b.display(); (ref:display3)

      MyClass<char> c;
      c.display();
    }
  #+end_src

  A few difficulties can be found in this file, making indexing difficult without the help of a
  full-fledged C++ compiler:

  1. Depending on the =DEBUG= preprocessor macro, the definition of the function =debug= might be found
     at line [[(debug1)]] or [[(debug2)]].

  2. The =display= identifier is used in several places to mean widely different things (for example
     at lines [[(display1)]] and [[(display2)]]). Context information is necessary to disambiguate uses of
     the same identifier.

  3. Even when =display= refers to the method of template class =MyClass<>=, a precise knowledge of the
     complex C++ template specialization rules is required to associate [[(display2)][a.display()]] with
     [[(defDisplayT)][MyClass<T>::display()]] and [[(display3)][b.display()]] with [[(defDisplayInt)][MyClass<int>::display()]].

  4. Some functions such as constructors or operators can be called without explicitly appearing in
     the code. For example, the [[(defCtor)][MyClass::MyClass()]] constructor is called at line [[(ctor)]].


  On the other hand, using a C++ compiler such as =clang= to parse this code and generate an AST
  requires information about the project configuration and its build environment:

  1. The =config.h= file could be automatically generated by =autoconf= or =CMake= and reside in a
     completely different directory than other source files. The compiler will typically need to be
     provided with =-I= command-line arguments to know where to find header files.

  2. The =DEBUG= macro could well be defined by the compilation command line (typically using a =-D=
     switch).

  A compiler-based indexing tool thus needs to be aware of the full compilation commands which are
  used to build the project, including for each source file:
  - the full list of command-line switches,
  - the directory from which the file is compiled.

  Such information, which we will refer to as a "compilation database" in the following, is usually
  found in the build system configuration, which can take a wide variety of forms: hand-crafted
  =Makefile=, =autotools= project, =CMake= project, /etc./

** Features

   =clang-tags= aims at providing the following features:
   1. generate a compilation database in a build-system-agnostic way,
   2. index the sources of the project,
   3. use this index to provide IDE-like features in Emacs.


* How to install

** Requirements

   - =libclang= (\ge 3.0)
   - =python= (\ge 2.3)
     - a version newer than 2.7 is recommended to benefit from the more recent =argparse= module.


** Build

   =clang-tags= uses [[http://www.cmake.org/][=CMake=]] as a build system.

   A complete build process could for example look like this:

   #+begin_src sh
     git clone https://github.com/ffevotte/clang-tags.git src
     mkdir build && cd build
     cmake ../src
   #+end_src



* How to use

** Creating the compilation database

   =clang-tags= uses a [[http://clang.llvm.org/docs/JSONCompilationDatabase.html][JSON compilation database]] to get the information needed to correctly build the
   project: compile directories and command-line switches. There are different ways to collect this
   information.

*** From a =CMake= project

    =CMake= (since version 2.8.5) supports the generation of a compilation database with the option
    =CMAKE_EXPORT_COMPILE_COMMANDS=. For a =CMake=-managed project, creating the compilation database is
    thus as simple as:
    #+begin_src sh
      cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ../src
    #+end_src


*** Tracing the standard build process

    #+begin_src sh
      clang-tags trace -- BUILD COMMAND
    #+end_src

    For non =CMake=-managed projects, there is no "free" way to build the compilation database. One
    way to get the necessary information consists in inspecting the build process as a black box
    using [[http://linux.die.net/man/1/strace][=strace=]] (also see [[https://github.com/rizsotto/Bear][=Bear=]] for a tool using =LD_PRELOAD= to implement the same kind of
    strategy).

    Such a method is inherently independent of the build process: Makefile (possibly
    autotools-generated), shell or python script, ... However, the downside with this approach is
    that =make= and other build systems traditionally only rebuild what's needed, and the generated
    compilation database can thus be incomplete.

    Example usage:
    #+begin_src sh
      make clean                 # Ensure that the whole project will be rebuilt
      clang-tags trace -- make   # Generate the compilation database
    #+end_src


*** Scanning the sources directory

    #+begin_src sh
      clang-tags scan SRC_DIR -- CLANG ARGS
    #+end_src

    For relatively simple projects, it can be sufficient to simply scan the top sources directory to
    find all =*.c= or =*.cxx= files, and additionally provide =clang-tags= with a set of command-line
    arguments necessary for =clang= to parse these files.

    Example usage:
    #+begin_src sh
      clang-tags scan ../src -- -I.
    #+end_src


** Indexing the source files

*** Creating the index

    #+begin_src sh
    clang-tags index [--emacs-conf SRC_DIR]
    #+end_src

    This command uses the compilation database to index all source files. An
    optional argument =--emacs-conf= allows generating a suitable =.dir-local.el=
    emacs configuration file in the sources directory.

*** Updating the index

    #+begin_src sh
    clang-tags update [--all]
    #+end_src

    This command updates the index. With the optional =--all= switch, the
    compilation database is also rebuilt using the same subcommand =trace= or
    =build= as previously.


** Using the Emacs UI

First, load the package using =M-x load-file RET path/to/clang-tags.el RET=

With the configuration file generated by the =clang-tags index= command, all
C/C++ source files in the indexed source directory should automatically activate
=clang-tags-mode= and have the =ct/default-directory= variable point to the
index directory.


*** Find the definition of the symbol at point

While in a source buffer, you can use =clang-tags= to find the location of the definition
of the symbol under point by pressing =M-<dot>=.

The list of relevant definitions is presented in a buffer, where pressing =RET= will take you to the
location of the definition.

*** Find all uses of a definition in the source base

After having looked for a definition of the symbol under point, and while in the definitions list
buffer, press =M-<comma>= to list all uses of the current definition in the source code base.

Results are presented in a =grep-mode= buffer.


* See also

- [[http://clang.llvm.org/doxygen/group__CINDEX.html][libclang API documentation]]
- [[http://llvm.org/devmtg/2010-11/Gregor-libclang.pdf][Doug Gregor's presentation on libclang]]
- [[https://github.com/drothlis/clang-ctags][clang-ctags]]: a similar project
  using libclang to generate =ctags= / =etags= index files.


* Contributing

If you make improvements to this code or have suggestions, please do not
hesitate to fork the repository or submit bug reports on
[[https://github.com/ffevotte/clang-tags][github]]. The repository's URL is:

    https://github.com/ffevotte/clang-tags.el.git


* License

Copyright (C) 2013 François Févotte.

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE. See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program. If not, see <http://www.gnu.org/licenses/>.
