#+TITLE: clang-tags
#+STYLE: <link type="text/css" href="worg.css" title="Standard" rel="stylesheet">
#+STYLE: <link type="text/css" href="worg-zenburn.css" title="Zenburn" rel="alternate stylesheet">
#+STYLE: <link type="text/css" href="worg-classic.css" title="Classic" rel="alternate stylesheet">
#+STYLE: <style type="text/css">
#+STYLE:   #text-1 pre.src { float: left; margin-right: 3em }
#+STYLE:   #sec-1-1 { clear: both; }
#+STYLE: </style>
#+BIND: org-export-html-postamble "Generated by %c using CSS stylesheets from <a href='http://www.orgmode.org/worg'>Worg</a>."
#+OPTIONS: author:nil timestamp:nil level:4 toc:2

=clang-tags= is a C / C++ source code indexing tool. Unlike many other indexing tools, =clang-tags=
relies on the [[http://clang.llvm.org][clang]] compiler (via the libclang interface) to analyse and index the source code base.


* Introduction

  Let us consider the following C++ code:

  #+include: "../tests/src/main.cxx" src c++ -n -r

  A few difficulties can be found in this file, making indexing difficult without the help of a
  full-fledged C++ compiler:

  1. Depending on the =DEBUG= preprocessor macro, the definition of the function =debug= might be found
     at line [[(debug1)]] or [[(debug2)]].

  2. The =display= identifier is used in several places to mean widely different things (for example
     at lines [[(display1)]] and [[(display2)]]). Context information is necessary to disambiguate uses of
     the same identifier.

  3. Even when =display= refers to the method of template class =MyClass<>=, a precise knowledge of the
     complex C++ template specialization rules is required to associate [[(display2)][a.display()]] with
     [[(defDisplayT)][MyClass<T>::display()]] and [[(display3)][b.display()]] with [[(defDisplayInt)][MyClass<int>::display()]].

  4. Some functions such as constructors or operators can be called without explicitly appearing in
     the code. For example, the [[(defCtor)][MyClass::MyClass()]] constructor is called at line [[(ctor)]].


  On the other hand, using a C++ compiler such as =clang= to parse this code and generate an AST
  requires information about the project configuration and its build environment:

  1. The =config.h= file could be automatically generated by =autoconf= or =CMake= and reside in a
     completely different directory than other source files. The compiler will typically need to be
     provided with =-I= command-line arguments to know where to find header files.

  2. The =DEBUG= macro could well be defined by the compilation command line (typically using a =-D=
     switch).

  A compiler-based indexing tool thus needs to be aware of the full compilation commands which are
  used to build the project, including for each source file:
  - the full list of command-line switches,
  - the directory from which the file is compiled.

  Such information, which we will refer to as a "compilation database" in the following, is usually
  found in the build system configuration, which can take a wide variety of forms: hand-crafted
  =Makefile=, =autotools= project, =CMake= project, /etc./

** Features

   =clang-tags= aims at providing the following features:
   1. generate a compilation database in a build-system-agnostic way,
   2. index the sources of the project,
   3. use this index to provide IDE-like features in Emacs.


** First steps for the impatient
    
   All details are explained later, but here are a few steps to get you started
   if you are too impatient to read. Otherwise, you may safely skip to the
   [[*Important%20notions][following section]].
    
   1. build the compilation database:
      #+include: "../tests/ct-trace" src sh :lines "3-"
      #+include: "../../build/tests/ct-trace.out" src fundamental

   2. load the compilation database:
      #+include: "../tests/ct-load" src sh :lines "3-"
      #+include: "../../build/tests/ct-load.out" src fundamental
    
   3. index the source files:
      #+include: "../tests/ct-index" src sh :lines "3-"
      #+include: "../../build/tests/ct-index.out" src fundamental
    
   4. find the definition location of the identifier located in =main.cxx= at
      offset 849:
      #+include: "../tests/ct-find-def-r" src sh :lines "3-"
      #+include: "../../build/tests/ct-find-def-r.out" src ct/find-def-rw
    
   5. find all uses of the =Cursor::location()= method (identified by its USR, as given in the
      second result of =clang-tags find-def= above):
      #+include: "../tests/ct-grep" src sh :lines "3-"
      #+include: "../../build/tests/ct-grep.out" src grep-rw


** Important notions

   The following terms are used throughout this guide:

   - Translation Unit ::
        A set of source code which is compiled together. Ordinarily, a translation units consists in
        a preprocessed source file, in which all header files have been included, macros have been
        expanded, and so on. In clang-tags a translation unit is identified by the set of
        command-line arguments which would be needed to compile it into an object file.

   - Definition       ::
        The place in the source code where a symbol is declared and/or defined. For each translation
        unit, a given symbol only has one definition location. However, different definition
        locations can be found for the same symbol across all translation units.  For example, the
        definition of local variable =a= in function =main= of =main.cxx= appears at line [[(ctor)]].

   - Reference        ::
        Each occurrence of a symbol name in the source code is seen as a reference to its
        definition. For example, the symbol =a= in expression =a.display()= on line [[(display2)]] is a
        reference to the definition at line [[(ctor)]].

   - Spelling         :: 
        In clang terminology, the name of a symbol as it appears in the source code is referred to
        as its spelling. For example, the spelling of the symbol defined at line [[(ctor)]] is the
        string "a".

   - Unified Symbol Resolution (USR) :: 
        A symbol can not be identified by its spelling only: context information is needed to
        disambiguate uses of the same spelling in different scopes. In order to uniquely identify a
        symbol across all translation units in a project, clang defines Unified Symbol
        Resolutions. For example the USR of the =display= symbol referred to on line [[(display2)]] is
        =c:@S@MyClass>#d@F@display#= whereas line [[(display3)]] refers to the symbol with USR
        =c:@S@MyClass>#I@F@display#=


* Command-line interface   

** Creating the compilation database

   =clang-tags= uses a [[http://clang.llvm.org/docs/JSONCompilationDatabase.html][JSON compilation database]] to get the information needed to correctly build the
   project: compile directories and command-line switches. There are different ways to collect this
   information.

*** From a =CMake= project

    =CMake= (since version 2.8.5) supports the generation of a compilation database with the option
    =CMAKE_EXPORT_COMPILE_COMMANDS=. For a =CMake=-managed project, creating the compilation database is
    thus as simple as:
    #+begin_src sh
      cmake -DCMAKE_EXPORT_COMPILE_COMMANDS=1 ../src
    #+end_src


*** Tracing the standard build process

    #+begin_src sh
      clang-tags trace -- BUILD COMMAND
    #+end_src

    For non =CMake=-managed projects, there is no "free" way to build the compilation database. One
    way to get the necessary information consists in inspecting the build process as a black box
    using [[http://linux.die.net/man/1/strace][=strace(1)=]] (also see [[https://github.com/rizsotto/Bear][=Bear=]] for a tool using =LD_PRELOAD= to implement the same kind of
    strategy).

    Such a method is inherently independent of the build process: Makefile (possibly
    autotools-generated), shell or python script, ... However, the downside with this approach is
    that =make= and other build systems traditionally only rebuild what's needed, and the generated
    compilation database can thus be incomplete. Such methods also depend on platform-specific
    features to inspect the build process.

    Example usage:
    #+begin_src sh
      make clean                 # Ensure that the whole project will be rebuilt
      clang-tags trace -- make   # Generate the compilation database
    #+end_src


*** Scanning the sources directory

    #+begin_src sh
      clang-tags scan SRC_DIR -- CLANG ARGS
    #+end_src

    For relatively simple projects, it can be sufficient to simply scan the top sources directory to
    find all =*.c= or =*.cxx= files, and additionally provide =clang-tags= with a set of command-line
    arguments necessary for =clang= to parse these files.

    Example usage:
    #+begin_src sh
      clang-tags scan ../src -- -I.
    #+end_src


** Indexing the source files

*** Creating the index

    #+begin_src sh
      clang-tags index [--emacs-conf SRC_DIR]
    #+end_src

    This command uses the compilation database to index all source files. An
    optional argument =--emacs-conf= allows generating a suitable =.dir-local.el=
    emacs configuration file in the sources directory.

*** Updating the index

    #+begin_src sh
      clang-tags update [--all]
    #+end_src

    This command updates the index. With the optional =--all= switch, the
    compilation database is also rebuilt using the same sub-command =trace= or
    =build= as previously.


** Looking for symbols

*** Finding the definition of a symbol

*** Looking for all references to a symbol



* Emacs user interface

First, load the package using =M-x load-file RET path/to/clang-tags.el RET=

With the configuration file generated by the =clang-tags index= command, all
C/C++ source files in the indexed source directory should automatically activate
=clang-tags-mode= and have the =ct/default-directory= variable point to the
index directory.


** Find the definition of the symbol at point

While in a source buffer, you can use =clang-tags= to find the location of the definition
of the symbol under point by pressing =M-<dot>=.

The list of relevant definitions is presented in a buffer, where pressing =RET= will take you to the
location of the definition.

** Find all uses of a definition in the source base

After having looked for a definition of the symbol under point, and while in the definitions list
buffer, press =M-<comma>= to list all uses of the current definition in the source code base.

Results are presented in a =grep-mode= buffer.


* See also

- [[http://clang.llvm.org/doxygen/group__CINDEX.html][libclang API documentation]]
- [[http://llvm.org/devmtg/2010-11/Gregor-libclang.pdf][Doug Gregor's presentation on libclang]]
- [[https://github.com/drothlis/clang-ctags][clang-ctags]]: a similar project
  using libclang to generate =ctags= / =etags= index files.
