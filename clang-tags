#! /usr/bin/python -O

"""
C and C++ source code base indexer using libclang.
"""

import os
import sys
import json
import shlex, subprocess
import time
import re
import types

### Common constants
logPath    = ".ct.log"
socketPath = ".ct.sock"
pidPath    = ".ct.pid"


### Helper functions
def endsWithOne (string, suffixes):
    "Return True iff STRING ends with one of SUFFIXES."
    for suffix in suffixes:
        if string.endswith(suffix):
            return True
    return False

def sendRequest (request, processOutput=sys.stdout.write):
    "Send a JSON request to the clang-tags daemon."
    #TODO: implement this in python rather than calling `socat`
    request = json.dumps (request)

    if os.getenv ("CLANG_TAGS_TEST") is None:
        cmd = ["socat", "-", "UNIX-CONNECT:%s" % socketPath]
    else:
        cmd = ["clang-tags-server", "--stdin"]

    process = subprocess.Popen (cmd,
                                stdin  = subprocess.PIPE,
                                stdout = subprocess.PIPE)
    process.stdin.write (request + "\n\n")

    while 1:
        # Use readline() to avoid buffering problems
        line = process.stdout.readline()
        if line == "":
            break
        processOutput (line)

    process.wait()
    sys.exit (process.returncode)



### Manage the server
def start (args):
    "Start the clang-tags server."

    if os.path.exists(socketPath):
        sys.stderr.write ("ERROR: socket already exists!\n")
        sys.exit (1)

    print "Starting server..."
    command = ["sh", "-c", "clang-tags-server >%s 2>&1 &" % logPath]
    sys.exit (subprocess.call (command))


def stop (args):
    "Stop the clang-tags server."

    request = {"command": "exit"}
    sendRequest (request)


def clean (args):
    "Clean server leftovers after a non-nice exit."

    command = ["rm", socketPath, pidPath]
    sys.exit (subprocess.call (command))


def kill (args):
    "Kill the clang-tags server."

    f = open (pidPath, "r")
    pid = f.readline().strip()
    f.close()

    command = ["kill", pid]
    sys.exit (subprocess.call (command))


### Generate the compilation database

def trace (args):
    """Entry point for generating a compilation database by tracing a build
    command."""
    compilers  = ["gcc", "g++", "c++", "clang", "clang++"]
    extensions = [".c", ".cxx", ".cc", ".C", ".cpp"]

    command  = ["strace", "-f", "-s256", "-etrace=execve,chdir", "-q"]
    command += args.command

    p = subprocess.Popen (command,
                          stderr = subprocess.PIPE)

    sourceFiles = {}
    cwd = os.getcwd()

    chdir_re = re.compile ("\[pid\s+\d+\] chdir\((.*)\) = 0")
    exec_re  = re.compile ("\[pid\s+\d+\] execve(\(.*\)) = ")

    for line in p.stderr:

        m = chdir_re.match (line)
        if m is not None:
            cwd = eval(m.group(1))
            continue

        m = exec_re.match (line)
        if m is not None:
            command = None
            sourceFile = None

            line = m.group(1)
            line = line.replace('"...', '"')
            line = re.sub(", \[/\* [^*]+ \*/\]", "", line)

            (programName, command) = eval(line)
            if endsWithOne(programName, [ "/" + c for c in compilers]):
                for arg in command:
                    if endsWithOne (arg, extensions) and os.path.exists (arg):
                        sourceFiles[arg] = (cwd, command)
                        break
    p.wait()

    compilationDb = []
    for sourceFile in sourceFiles:
        (directory, command) = sourceFiles[sourceFile]
        compilationDb.append ({"file": os.path.realpath(sourceFile),
                               "directory": directory,
                               "command": subprocess.list2cmdline(command)})
    f = open ("compile_commands.json", "w")
    json.dump(compilationDb, f,
              indent=4)
    f.close()


def scan (args):
    """Entry point for generating a compilation database by scanning a sources
    directory."""
    srcdir = args.srcdir
    clangArgs = args.clangArgs
    compiler = args.compiler

    compilationDb = []
    for (root, _, files) in os.walk (srcdir):
        for fileName in files:
            if endsWithOne (fileName, [".c", ".cxx", ".cc", ".C"]):
                sourceFile = os.path.realpath (os.path.join (root, fileName))
                command  = "%s %s" % (compiler, sourceFile)
                command += " " + subprocess.list2cmdline(clangArgs)
                compilationDb.append({"file": sourceFile,
                                      "directory": ".",
                                      "command": command})
    f = open ("compile_commands.json", "w")
    json.dump(compilationDb, f,
              indent=4)
    f.close()


### Manage the source files index
def load (args):
    "Entry point for reading a compilation database."

    request = {"command": "load",
               "database": args.compilationDB}
    sendRequest (request)


def index (args):
    "Entry point for indexing the source code base."

    exclude = [os.path.realpath(d) for d in args.exclude]

    request = {"command": "index",
               "exclude": exclude}
    sendRequest (request)


def update (args):
    "Entry point for updating the source code base index"

    request = {"command": "update"}
    sendRequest (request)



### IDE-like features
def findDefinition (args):
    "Entry point for finding the definition of an identifier"
    fileName = os.path.realpath (args.fileName)

    request = {"command":   "find",
               "file":      fileName,
               "offset":    args.offset,
               "fromIndex": args.fromIndex}

    def processOutput (line):
        try:
            refDef = json.loads (line)
            refDef["ref"]["file"] = os.path.relpath (refDef["ref"]["file"])
            refDef["def"]["file"] = os.path.relpath (refDef["def"]["file"])
            refDef["def"]["col2"] -= 1

            sys.stdout.write ("-- %(substring)s -- %(kind)s %(spelling)s\n" % refDef["ref"])
            sys.stdout.write ("   %(file)s:%(line1)d-%(line2)d:%(col1)d-%(col2)d: %(spelling)s\n"
                              % refDef["def"])
            sys.stdout.write ("   %(usr)s\n" % refDef["def"])
            sys.stdout.write ("\n")
        except:
            sys.stdout.write (line)

    sendRequest (request, processOutput)


def grep (args):
    "Entry point for finding the uses of a definition"

    request = {"command": "grep",
               "usr": args.usr}

    def processOutput (line):
        try:
            ref = json.loads (line)
            ref["file"] = os.path.relpath (ref["file"])

            sys.stdout.write ("%(file)s:%(line1)s:%(lineContents)s\n" % ref)
        except:
            sys.stdout.write (line)

    sendRequest (request, processOutput)


def complete (args):
    "Entry point for automatic completion"

    request = {"command": "complete",
               "file": os.path.realpath (args.fileName),
               "line": args.line,
               "column": args.column}
    sendRequest (request)



### Process command-line arguments
def main_argparse ():
    "Entry point for the application"

    parser = argparse.ArgumentParser (
        description = "Index a source code base using libclang.")

    parser.add_argument ("--debug", "-d", action = 'store_true',
                         help = "print debugging information")

    subparsers = parser.add_subparsers (metavar = "SUBCOMMAND")


    # Manage the server
    subparsers.add_parser (
        "start",
        help = "start the clang-tags server",
        description = "Start the clang-tags server."
        ).set_defaults (fun = start)

    subparsers.add_parser (
        "stop",
        help = "shutdown the clang-tags server",
        description = "Shutdown the clang-tags server."
        ).set_defaults (fun = stop)

    subparsers.add_parser (
        "kill",
        help = "kill the clang-tags server",
        description = "Kill the clang-tags server."
        ).set_defaults (fun = kill)

    subparsers.add_parser (
        "clean",
        help = "clean-up after a non-nice server shutdown",
        description = "Clean up after a non-nice server shutdown:"
        " pid file and server socket are wiped."
        ).set_defaults (fun = clean)


    # Create the compilation database
    parserTrace = subparsers.add_parser (
        "trace", help = "trace a build command",
        description =
        "Create a compilation database by tracing a build command.")
    parserTrace.add_argument (
        "command",
        metavar = "COMMAND",
        nargs = argparse.REMAINDER,
        help = "build command line")
    parserTrace.set_defaults (sourceType = "trace")
    parserTrace.set_defaults (fun = trace)


    parserScan = subparsers.add_parser (
        "scan", help = "scan a source directory",
        description =
        "Create a compilation database by scanning a source directory")
    parserScan.add_argument ("--compiler", "-c",
                             default = "gcc",
                             help = "compiler name (default: gcc)")
    parserScan.add_argument ("srcdir",
                             help = "top sources directory")
    parserScan.add_argument ("clangArgs",
                             metavar = "CLANG_ARGS",
                             nargs = argparse.REMAINDER,
                             help = "additional clang command-line arguments")
    parserScan.set_defaults (sourceType = "scan")
    parserScan.set_defaults (fun = scan)


    # Manage the source files index
    parserLoad = subparsers.add_parser (
        "load", help = "load a compilation database",
        description = "Read the compilation commands needed to build the"
        " project from a compilation database.")
    parserLoad.add_argument ("compilationDB",
                             metavar = "FILEPATH",
                             help = "path to the compilation database",
                             nargs = "?",
                             default = "compile_commands.json")
    parserLoad.set_defaults (fun = load)


    parserIndex = subparsers.add_parser (
        "index", help = "index source code base",
        description = "Create an index of all tags in the source code base."
        " Source files and compilation commands are taken from a clang"
        " \"compilation database\" in JSON format, previously read using"
        " the \"load\" subcommand.")
    parserIndex.add_argument (
        "--exclude", "-e",
        metavar = "DIR",
        action = "append",
        help = "do not index files under DIR")
    parserIndex.add_argument (
        "--exclude-clear", "-E",
        dest="exclude",
        action="store_const", const=[],
        help = "reset exclude list")
    parserIndex.set_defaults (exclude = ["/usr"])
    parserIndex.set_defaults (fun = index)


    parserUpdate = subparsers.add_parser (
        "update",
        help = "update index",
        description =
        "Update the source code base index, using the same arguments as "
        "previous call to `index'")
    parserUpdate.set_defaults (fun = update)


    # IDE-like features
    parserFindDef = subparsers.add_parser (
        "find-def",
        help = "find the definition of an identifier in a source file",
        description = "Find the definition location of an identifier in a "
        "source file.")
    parserFindDef.add_argument ("fileName", metavar = "FILE_NAME",
                                help = "source file name")
    parserFindDef.add_argument ("offset", metavar = "OFFSET",
                                help = "offset in bytes")
    parserFindDef.add_argument ("--index", "-i",
                                dest = "fromIndex",
                                action = "store_true",
                                help = "look for the definition in the index")
    parserFindDef.add_argument ("--recompile", "-r",
                                dest = "fromIndex",
                                action = "store_false",
                                help =
                                "recompile the file to find the definition")
    parserFindDef.set_defaults (fromIndex = True)
    parserFindDef.set_defaults (fun = findDefinition)


    parserGrep = subparsers.add_parser (
        "grep",
        help = "find all uses of a definition",
        description =
        "Find all uses of a definition, identified by its USR (Unified Symbol "
        "Resolution). Outputs results in a grep-like format.")
    parserGrep.add_argument ("usr",
                             metavar = "USR",
                             help = "USR for the definition")
    parserGrep.set_defaults (fun = grep)


    parserComplete = subparsers.add_parser (
        "complete",
        help = "find completions at point",
        description =
        "Find possible code completions at a given position in the source code.")
    parserComplete.add_argument ("fileName", metavar = "FILE_NAME",
                                 help = "source file name")
    parserComplete.add_argument ("line", metavar = "LINE",
                                 help = "Line number")
    parserComplete.add_argument ("column", metavar = "COLUMN",
                                 help = "Column number")
    parserComplete.set_defaults (fun = complete)


    args = parser.parse_args ()
    args.fun (args)



if __name__ == "__main__":
    try:
        import argparse
    except ImportError:
        import arg2opt as argparse
    main_argparse ()
