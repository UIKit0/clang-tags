#! /usr/bin/python

"""
C and C++ source code base indexer using libclang.
"""

import os
import sys
import argparse
import json
import shlex, subprocess
import time
import pickle

tagsFileName = ".ct.tags"
dbFileName   = ".ct.db"
rcFileName   = ".ct.rc"

class CompilationCommand:
    """A clang compilation command, including directory and clang command-line
    arguments"""

    def __init__ (self, directory, command):
        self.directory = directory
        self.clangArgs = shlex.split(command)[1:]

class CompilationDatabase:
    """A database listing all necessary compilation commands to index a source
    code base"""

    def __init__ (self, jsonDb = None):
        if jsonDb is not None:
            f = open (jsonDb, "r")
            db = json.load (f)
            f.close()

            self.compilationCommands = {}

            for compilationCommand in db:
                sourceFile = compilationCommand["file"]
                directory  = compilationCommand["directory"]
                command    = compilationCommand["command"]
                self.compilationCommands[sourceFile] = \
                    CompilationCommand (directory, command)
        else:
            raise RuntimeError ("No source were given to populate the "
                                "compilation database.")

    def __str__ (self):
        res = ""
        for sourceFile in self.compilationCommands:
            compilationCommand = self.compilationCommands[sourceFile]
            res += "%s\n" % sourceFile
            res += "  %s\n" % compilationCommand.directory
            res += "  %s\n\n" % str(compilationCommand.clangArgs)
        return res

    def __getitem__ (self, sourceFile):
        return self.compilationCommands[sourceFile]

    def sourceFiles (self):
        "List of all source files in the compilation database"
        return self.compilationCommands.keys()

    def addHeader (self, headerFileName, sourceFileName):
        """Add a header file to the database by copying the compilation command
        of a source file which includes it"""
        self.compilationCommands[headerFileName] = \
            self.compilationCommands[sourceFileName]


def saveCompilationDatabase (cdb):
    "Persistently save a compilation database to the `dbFileName' file"

    f = open (dbFileName, "w")
    pickle.dump (cdb, f)
    f.close()

def loadCompilationDatabase ():
    "Load a compilation database from the `dbFileName' file"

    f = open (dbFileName, "r")
    cdb = pickle.load (f)
    f.close()
    return cdb

def saveArguments (args):
    "Persistently save a `parseargs' arguments list to the `rcFileName' file"

    f = open (rcFileName, "w")
    pickle.dump (args, f)
    f.close()

def loadArguments ():
    "Load an arguments list from the `rcFileName' file"

    f = open (rcFileName, "r")
    args = pickle.load (f)
    f.close()
    return args

def populateTags (args):
    "Create and populate a tags database"
    cdb = CompilationDatabase (jsonDb = args.json)

    tagsFile = open (tagsFileName, "w")

    sourceFiles = {}

    for sourceFile in cdb.sourceFiles():
        compilationCommand = cdb[sourceFile]
        command = ["clang-tags-index", "--"]
        command += compilationCommand.clangArgs

        begin = time.time()
        sys.stderr.write ("%-70s" % (sourceFile + "..."))
        process = subprocess.Popen (command,
                                    cwd = compilationCommand.directory,
                                    stdout = subprocess.PIPE)

        for line in process.stdout:
            tagsFile.write (line)
            line = line.partition (" ")[2]
            fileName = line.partition (":")[0]
            if fileName not in sourceFiles:
                sourceFiles[fileName] = sourceFile

        process.wait ()
        sys.stderr.write ("\t%.2fs.\n" % (time.time() - begin))

    tagsFile.close()

    for fileName in sourceFiles:
        if fileName not in cdb.sourceFiles():
            cdb.addHeader (fileName, sourceFiles[fileName])

    saveCompilationDatabase (cdb)


def index (args):
    "Entry point for indexing the source code base"
    saveArguments (args)
    populateTags (args)

    if args.emacsConf is not None:
        f = open (os.path.join (args.emacsConf, ".dir-locals.el"), "w")
        f.write (
            ";; WARNING: this file has been automatically generated by clang-args\n"
            ";; any modification you do might be overwritten.\n"
            "((c++-mode\n"
            "  (ct/default-directory . \"%s\")))\n"
            % os.getcwd())
        f.close ()


def update (args):
    "Entry point for updating the source code base index"

    args = loadArguments()
    populateTags (args)


def findDefinition (args):
    "Entry point for finding the definition of an identifier"
    cdb = loadCompilationDatabase()

    fileName = args.fileName
    offset = args.offset
    compilationCommand = cdb[fileName]

    command = ["clang-tags-def", fileName, offset, "--"]
    command += compilationCommand.clangArgs

    process = subprocess.Popen (command,
                                cwd = compilationCommand.directory)
    process.wait()


def grep (args):
    "Entry point for finding the uses of a definition"
    usr = args.usr + " "
    tags = open (tagsFileName, "r")
    for line in tags:
        if line.startswith (usr):
            line = line.partition (" ")[2]
            print line
    tags.close()


def main ():
    "Entry point for the application"

    parser = argparse.ArgumentParser (
        description = "Index a source code base using libclang.")
    subparsers = parser.add_subparsers (title = "subcommands")

    parserIndex = subparsers.add_parser (
        "index", help = "index source code base",
        description =
        "Create an index of all tags in the source code base. "
        "Source files and compilation commands are taken from a clang "
        "\"compilation database\" in JSON format.")
    parserIndex.add_argument (
        "--json",
        metavar = "COMPILE_DB",
        help = "clang compilation database in JSON format")
    parserIndex.add_argument (
        "--emacs-conf", metavar = "SRCDIR",
        dest = "emacsConf",
        help = "create an emacs configuration file in the top source files "
            "directory")
    parserIndex.set_defaults (fun = index)


    parserUpdate = subparsers.add_parser (
        "update",
        help = "update index",
        description =
        "Update the source code base index, using the same source as previous "
        "call to `index'")
    parserUpdate.set_defaults (fun = update)


    parserFindDef = subparsers.add_parser (
        "find-def",
        help = "find the definition of an identifier in a source file",
        description = "Find the definition location of an identifier in a "
        "source file.")
    parserFindDef.add_argument ("fileName", metavar = "FILE_NAME",
                                help = "source file name")
    parserFindDef.add_argument ("offset", metavar = "OFFSET",
                                help = "offset in bytes")
    parserFindDef.set_defaults (fun = findDefinition)


    parserGrep = subparsers.add_parser (
        "grep",
        help = "find all uses of a definition",
        description =
        "Find all uses of a definition, identified by its USR (Unified Symbol "
        "Resolution). Outputs results in a grep-like format.")
    parserGrep.add_argument ("usr", metavar = "USR",
                             help = "USR for the definition")
    parserGrep.set_defaults (fun = grep)

    args = parser.parse_args ()
    args.fun (args)

if __name__ == "__main__":
    main ()
