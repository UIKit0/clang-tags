#! /usr/bin/python -O

"""
C and C++ source code base indexer using libclang.
"""

import os
import sys
import json
import shlex, subprocess
import time
import re
import types

### Helper functions
def endsWithOne (string, suffixes):
    "Return True iff STRING ends with one of SUFFIXES."
    for suffix in suffixes:
        if string.endswith(suffix):
            return True
    return False

def sendRequest (request):
    "Send a JSON request to the clang-tags daemon on port 1313."
    #TODO: implement this in python rather than calling `socat`
    request = json.dumps (request)

    cmd = ["socat", "-", "UNIX-CONNECT:/tmp/clang-tags"]
    process = subprocess.Popen (cmd,
                                stdin  = subprocess.PIPE,
                                stdout = sys.stdout)
    process.stdin.write (request + "\n\n")
    process.wait()


### Entry points for the subcommands

def trace (args):
    """Entry point for generating a compilation database by tracing a build
    command."""
    compilers  = ["gcc", "g++", "c++", "clang", "clang++"]
    extensions = [".c", ".cxx", ".cc", ".C"]

    command  = ["strace", "-f", "-s256", "-etrace=execve,chdir", "-q"]
    command += args.command

    p = subprocess.Popen (command,
                          stderr = subprocess.PIPE)

    sourceFiles = {}
    cwd = os.getcwd()

    chdir_re = re.compile ("\[pid\s+\d+\] chdir\((.*)\) = 0")
    exec_re  = re.compile ("\[pid\s+\d+\] execve(\(.*\)) = ")

    for line in p.stderr:

        m = chdir_re.match (line)
        if m is not None:
            cwd = eval(m.group(1))
            continue

        m = exec_re.match (line)
        if m is not None:
            command = None
            sourceFile = None

            line = m.group(1)
            line = line.replace('"...', '"')
            line = re.sub(", \[/\* [^*]+ \*/\]", "", line)

            (programName, command) = eval(line)
            if endsWithOne(programName, [ "/" + c for c in compilers]):
                for arg in command:
                    if endsWithOne (arg, extensions) and os.path.exists (arg):
                        sourceFiles[arg] = (cwd, command)
                        break
    p.wait()

    compilationDb = []
    for sourceFile in sourceFiles:
        (directory, command) = sourceFiles[sourceFile]
        compilationDb.append ({"file": sourceFile,
                               "directory": directory,
                               "command": subprocess.list2cmdline(command)})
    f = open ("compile_commands.json", "w")
    json.dump(compilationDb, f,
              indent=4)
    f.close()


def scan (args):
    """Entry point for generating a compilation database by scanning a sources
    directory."""
    srcdir = args.srcdir
    clangArgs = args.clangArgs
    compiler = args.compiler

    compilationDb = []
    for (root, _, files) in os.walk (srcdir):
        for fileName in files:
            if endsWithOne (fileName, [".c", ".cxx", ".cc", ".C"]):
                sourceFile = os.path.realpath (os.path.join (root, fileName))
                command  = "%s %s" % (compiler, sourceFile)
                command += " " + subprocess.list2cmdline(clangArgs)
                compilationDb.append({"file": sourceFile,
                                      "directory": ".",
                                      "command": command})
    f = open ("compile_commands.json", "w")
    json.dump(compilationDb, f,
              indent=4)
    f.close()


def load (args):
    "Entry point for reading a compilation database."

    request = {"command": "load"}
    sendRequest (request)


def index (args):
    "Entry point for indexing the source code base."

    exclude = [os.path.realpath(d) for d in args.exclude]

    request = {"command": "index",
               "exclude": exclude}
    sendRequest (request)


def update (args):
    "Entry point for updating the source code base index"

    request = {"command": "update"}
    sendRequest (request)


def findDefinition (args):
    "Entry point for finding the definition of an identifier"
    fileName = os.path.realpath (args.fileName)

    request = {"command":   "find",
               "file":      fileName,
               "offset":    args.offset,
               "fromIndex": args.fromIndex}
    sendRequest (request)


def grep (args):
    "Entry point for finding the uses of a definition"

    request = {"command": "grep",
               "usr": args.usr}
    sendRequest (request)


def complete (args):
    "Entry point for automatic completion"

    request = {"command": "complete",
               "file": os.path.realpath (args.fileName),
               "line": args.line,
               "column": args.column}
    sendRequest (request)


def shutdown (args):
    "Entry point for server shutdown"

    request = {"command": "exit"}
    sendRequest (request)


def main_argparse ():
    "Entry point for the application"

    parser = argparse.ArgumentParser (
        description = "Index a source code base using libclang.")

    parser.add_argument ("--debug", "-d", action = 'store_true',
                         help = "print debugging information")

    subparsers = parser.add_subparsers (metavar = "SUBCOMMAND")

    parserTrace = subparsers.add_parser (
        "trace", help = "trace a build command",
        description =
        "Create a compilation database by tracing a build command.")
    parserTrace.add_argument (
        "command",
        metavar = "COMMAND",
        nargs = argparse.REMAINDER,
        help = "build command line")
    parserTrace.set_defaults (sourceType = "trace")
    parserTrace.set_defaults (fun = trace)


    parserScan = subparsers.add_parser (
        "scan", help = "scan a source directory",
        description =
        "Create a compilation database by scanning a source directory")
    parserScan.add_argument ("--compiler", "-c",
                             default = "gcc",
                             help = "compiler name (default: gcc)")
    parserScan.add_argument ("srcdir",
                             help = "top sources directory")
    parserScan.add_argument ("clangArgs",
                             metavar = "CLANG_ARGS",
                             nargs = argparse.REMAINDER,
                             help = "additional clang command-line arguments")
    parserScan.set_defaults (sourceType = "scan")
    parserScan.set_defaults (fun = scan)


    parserLoad = subparsers.add_parser (
        "load", help = "load a compilation database",
        description = "Read the compilation commands needed to build the"
        " project from a compilation database.")
    parserLoad.set_defaults (fun = load)


    parserIndex = subparsers.add_parser (
        "index", help = "index source code base",
        description = "Create an index of all tags in the source code base."
        " Source files and compilation commands are taken from a clang"
        " \"compilation database\" in JSON format, previously read using"
        " the \"load\" subcommand.")
    parserIndex.add_argument (
        "--exclude", "-e",
        metavar = "DIR",
        action = "append",
        help = "do not index files under DIR")
    parserIndex.add_argument (
        "--exclude-clear", "-E",
        dest="exclude",
        action="store_const", const=[],
        help = "reset exclude list")
    parserIndex.set_defaults (exclude = ["/usr"])
    parserIndex.set_defaults (fun = index)


    parserUpdate = subparsers.add_parser (
        "update",
        help = "update index",
        description =
        "Update the source code base index, using the same arguments as "
        "previous call to `index'")
    parserUpdate.set_defaults (fun = update)


    parserFindDef = subparsers.add_parser (
        "find-def",
        help = "find the definition of an identifier in a source file",
        description = "Find the definition location of an identifier in a "
        "source file.")
    parserFindDef.add_argument ("fileName", metavar = "FILE_NAME",
                                help = "source file name")
    parserFindDef.add_argument ("offset", metavar = "OFFSET",
                                help = "offset in bytes")
    parserFindDef.add_argument ("--index", "-i",
                                dest = "fromIndex",
                                action = "store_true",
                                help = "look for the definition in the index")
    parserFindDef.add_argument ("--recompile", "-r",
                                dest = "fromIndex",
                                action = "store_false",
                                help =
                                "recompile the file to find the definition")
    parserFindDef.set_defaults (fromIndex = True)
    parserFindDef.set_defaults (fun = findDefinition)


    parserGrep = subparsers.add_parser (
        "grep",
        help = "find all uses of a definition",
        description =
        "Find all uses of a definition, identified by its USR (Unified Symbol "
        "Resolution). Outputs results in a grep-like format.")
    parserGrep.add_argument ("usr",
                             metavar = "USR",
                             help = "USR for the definition")
    parserGrep.set_defaults (fun = grep)


    parserComplete = subparsers.add_parser (
        "complete",
        help = "find completions at point",
        description =
        "Find possible code completions at a given position in the source code.")
    parserComplete.add_argument ("fileName", metavar = "FILE_NAME",
                                 help = "source file name")
    parserComplete.add_argument ("line", metavar = "LINE",
                                 help = "Line number")
    parserComplete.add_argument ("column", metavar = "COLUMN",
                                 help = "Column number")
    parserComplete.set_defaults (fun = complete)


    parserExit = subparsers.add_parser (
        "exit", help = "shutdown the clang-tags server")
    parserExit.set_defaults (fun = shutdown)


    args = parser.parse_args ()
    args.fun (args)


def main_optparse ():
    """Main entry point for the application, used for python <2.7 when argparse
    is not available."""

    parser = optparse.OptionParser(
        usage = "usage: %prog SUBCOMMAND [options]",
        description = "Index a source code base using libclang. "
        "Please consult the full help on: https://github.com/ffevotte/clang-tags.")
    parser.add_option ("--debug", dest="debug", action = 'store_true',
                       help = "print debugging information")

    subcommand = sys.argv[1]
    if subcommand == "trace":
        (options, args) = parser.parse_args (sys.argv[2:])
        options.command = args
        options.fun = trace
        trace (options)

    elif subcommand == "scan":
        parser.add_option ("--compiler", "-c", default = "gcc")
        (options, args) = parser.parse_args (sys.argv[2:])
        options.srcdir = args[0]
        options.clangArgs = args[1:]
        options.fun = scan
        scan (options)

    elif subcommand == "load":
        (options, args) = parser.parse_args (sys.argv[2:])
        options.fun = scan
        load (options)

    elif subcommand == "index":
        parser.add_option ("--exclude-clear", "-E", dest="exclude",
                           action="store_const", const=[])
        parser.add_option ("--exclude", "-e", action="append")
        parser.set_defaults (exclude = ["/usr"])
        (options, args) = parser.parse_args (sys.argv[2:])
        index (options)

    elif subcommand == "update":
        (options, args) = parser.parse_args (sys.argv[2:])
        update (options)

    elif subcommand == "find-def":
        parser.add_option ("--index", "-i",
                           dest = "fromIndex",
                           action = "store_true")
        parser.add_option ("--recompile", "-r",
                           dest = "fromIndex",
                           action = "store_false")
        parser.set_defaults (fromIndex = True)
        (options, args) = parser.parse_args (sys.argv[2:])
        options.fileName = args[0]
        options.offset = args[1]
        findDefinition (options)

    elif subcommand == "grep":
        (options, args) = parser.parse_args (sys.argv[2:])
        options.usr = args[0]
        grep (options)

    elif subcommand == "complete":
        (options, args) = parser.parse_args (sys.argv[2:])
        options.fileName = args[0]
        options.line = args[1]
        options.column = args[2]
        complete (options)

    elif subcommand == "exit":
        (options, args) = parser.parse_args (sys.argv[2:])
        shutdown (options)

    else:
        sys.stderr.write ("unknown subcommand: %s\n" % subcommand)
        parser.print_help()

if __name__ == "__main__":
    try:
        import argparse
        main_argparse ()
    except ImportError:
        import optparse
        main_optparse ()
